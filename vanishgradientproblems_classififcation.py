# -*- coding: utf-8 -*-
"""VanishGradientProblems_Classififcation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iD3B2tVm3hzxVG1ezDcDPJOFN3L68seV
"""

import tensorflow as tf
import keras
from keras.layers import Dense
from keras.models import Sequential
import matplotlib.pyplot as plt
import numpy as np
from sklearn.datasets import make_moons
from sklearn.model_selection import train_test_split

X,y=make_moons(n_samples=250,noise=0.05,random_state=42)

X.shape

X

y

plt.scatter(X[:,0],X[:,1],c=y,s=100)
plt.show()

model=Sequential()

model.add(Dense(10, activation='sigmoid',input_dim=2))
model.add(Dense(10,activation='sigmoid'))
model.add(Dense(10,activation='sigmoid'))
model.add(Dense(10,activation='sigmoid'))
model.add(Dense(10,activation='sigmoid'))
model.add(Dense(10,activation='sigmoid'))
model.add(Dense(10,activation='sigmoid'))
model.add(Dense(10,activation='sigmoid'))
model.add(Dense(10,activation='sigmoid'))
model.add(Dense(10,activation='sigmoid'))
model.add(Dense(10,activation='sigmoid'))
model.add(Dense(1,activation='sigmoid'))

model.compile(loss='binary_crossentropy',optimizer='adam',metrics=['accuracy'])

#weights in neural network
model.get_weights()[0]

old_weights=model.get_weights()[0]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=42)

model.fit(X_train,y_train,epochs=100)

new_weights = model.get_weights()[0]

new_weights

old_weights

percent_change = abs(100*(old_weights - new_weights)/ old_weights)

percent_change

from mlxtend.plotting import plot_decision_regions
plot_decision_regions(X_train, y_train.astype('int'), clf=model, legend=2)

"""REDUCE MODEL COMPLEXITY"""

mdl1=Sequential()
mdl1.add(Dense(10, activation='sigmoid', input_dim=2))
mdl1.add(Dense(10, activation='sigmoid'))
mdl1.add(Dense(10, activation='sigmoid'))
mdl1.add(Dense(10, activation='sigmoid'))
mdl1.add(Dense(1, activation='sigmoid'))

mdl1.compile(loss='binary_crossentropy', optimizer= 'adam',metrics=['accuracy'])

old_weights1=mdl1.get_weights()[0]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=42)

mdl1.fit(X_train, y_train, epochs = 100)

new_weight1 = mdl1.get_weights()[0]

new_weight1

old_weights1

percent_change = abs(100*(old_weights1 - new_weight1)/ old_weights1)

percent_change

from mlxtend.plotting import plot_decision_regions
plot_decision_regions(X_train, y_train.astype('int'), clf=mdl1, legend=2)

"""BUILDING RELU ACTIVATION FUNCTION"""

model2 = Sequential()

model2.add(Dense(10, activation='relu', input_dim=2))#input layers
model2.add(Dense(10, activation='relu'))#hidden layers
model2.add(Dense(10, activation='relu'))
model2.add(Dense(10, activation='relu'))
model2.add(Dense(10, activation='relu'))
model2.add(Dense(10, activation='relu'))
model2.add(Dense(10, activation='relu'))
model2.add(Dense(10, activation='relu'))
model2.add(Dense(10, activation='relu'))
model2.add(Dense(10, activation='relu'))
model2.add(Dense(10, activation='relu'))
model2.add(Dense(1, activation='sigmoid')) #outputlayer

model2.compile(loss='binary_crossentropy', optimizer= 'adam',metrics=['accuracy'])

model2.get_weights()[0]

old_weights3 = model.get_weights()[0]

old_weights3

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=42)

model2.fit(X_train, y_train, epochs = 100)

new_weight3 = model2.get_weights()[0]

new_weight3

old_weights3

percent_change3 = abs(100*(old_weights3 - new_weight3)/ old_weights3)

percent_change3

from mlxtend.plotting import plot_decision_regions
plot_decision_regions(X_train, y_train.astype('int'), clf=model2, legend=2)

"""WEIGHT INITIALIZATION"""

model3 = Sequential()

model3.add(Dense(10, activation='relu', input_dim=2, kernel_initializer='he_normal'))
model3.add(Dense(10, activation='relu', kernel_initializer='he_normal'))
model3.add(Dense(10, activation='relu', kernel_initializer='he_normal'))
model3.add(Dense(10, activation='relu', kernel_initializer='he_normal'))
model3.add(Dense(1, activation='sigmoid'))

model3.compile(loss='binary_crossentropy', optimizer= 'adam',metrics=['accuracy'])

old_weights03 = model3.get_weights()[0]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=42)

model3.fit(X_train, y_train, epochs = 100)

new_weight03 = model3.get_weights()[0]

new_weight03

old_weights03

percent_change = abs(100*(old_weights03 - new_weight03)/ old_weights03)

percent_change

from mlxtend.plotting import plot_decision_regions
plot_decision_regions(X_train, y_train.astype('int'), clf=model3, legend=2)

